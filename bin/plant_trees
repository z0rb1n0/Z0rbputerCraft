


os.loadAPI("/" .. fs.getDir(shell.getRunningProgram()) .. "/../lib/inventory");
os.loadAPI("/" .. fs.getDir(shell.getRunningProgram()) .. "/../lib/navigation");


local argv = { ... };
local size_x = tonumber(argv[1]);
local size_y = tonumber(argv[2]);
local initial_step_ahead = tonumber(argv[3]);
local initial_step_right = tonumber(argv[4]);



	if (initial_step_ahead == nil) then
		initial_step_ahead = 1;
	end;

	if (initial_step_right == nil) then
		initial_step_right = 1;
	end;
	

	if (((size_x == nil) or (size_x < 1)) or ((size_y == nil) or (size_y < 1)) or ((initial_step_ahead == nil) or (initial_step_ahead < 1)) or ((initial_step_right == nil) or (initial_step_right < 1))) then
		print("Usage:");
		print("    plant_trees <size_x> <size_y> [ initial_step_ahead = 1 [ initial_step_right = 1 ]]");
		print("    (X/Y/stepahead values must be positive)");
		return 1;
	end;


	print("Checking for sufficient resources");
	if (inventory.count_items("MINECRAFT:SAPLING") < (size_x * size_y)) then
		print("Insufficient saplings for the specified area size");
		return false;
	end;

	
	print("Going one level higher and moving to initial square");
	navigation.dig_and_go("U");
	navigation.offset_force_z(0); -- this doesn't count
	
	local step_loop;
	-- let's move ahead as much as it takes
	for step_loop = 1, initial_step_ahead do
		navigation.dig_and_go("N");
		navigation.offset_force_y(0); -- this doesn't count
	end;

	for step_loop = 1, initial_step_right do
		navigation.dig_and_go("E");
		navigation.offset_force_x(0); -- this doesn't count
	end;

	print("Replanting " .. size_x .. "x" .. size_y .. " saplings");
	

	local low_fuel = false;
	local layer_complete = false;
	local returning_y = false;
	local returning_x = false;
	
	local curr_offset_x = 0;
	local curr_offset_y = 0;

	-- we stop if:
	--  - we're going down and we hit bedrock
	--  - we're finished
	--  - we've got just enough fuel to get back to origin


	while (not (layer_complete)) do

		-- we store these not to make too many calls
		curr_offset_x = navigation.offset_get_x();
		curr_offset_y = navigation.offset_get_y();
		

		-- unfortunately we need to check if we still have saplings in our slot on every loop
		local curr_item = inventory.current_item();
		
		if ((curr_item == nil) or (string.upper(inventory.current_item()) ~= "MINECRAFT:SAPLING")) then
			print("Slot " .. turtle.getSelectedSlot() .. " ran out of saplings. Switching to the next available stack");
			turtle.select(inventory.find_item("MINECRAFT:SAPLING"));
		end;


		-- if all is well below, we plant the sapling
		if (turtle.detectDown()) then
			print("Block below is occupied at offset " .. curr_offset_x .. ":" .. curr_offset_y .. ". Skipping");
		else
			turtle.placeDown();
		end;


		-- did we just complete a column?
		if ((returning_y and (curr_offset_y == 0)) or ((not returning_y) and (curr_offset_y >= (size_y - 1)))) then
			-- Yes we are. did we just complete a row too?
			if ((returning_x and (curr_offset_x == 0)) or ((not returning_x) and (curr_offset_x >= (size_x - 1)))) then

				-- we just completed a column AND a row. Time to invert everything and loop out.
				returning_y = (not returning_y);
				returning_x = (not returning_x);
				layer_complete = true;

				-- we also ditch all the rubbish and refuel if possible/needed
				print("Planting complete. Refueling");

				local slot_idx;
				local slot_info;

				for slot_idx = 1, 16 do

					turtle.select(slot_idx);
					slot_info = turtle.getItemDetail(slot_idx);
					previous_fuel_level = turtle.getFuelLevel();

					if (slot_info) then
						if (navigation.blacklisted_fuels[string.upper(slot_info.name)] == nil) then
							if (previous_fuel_level < (turtle.getFuelLimit() / 2)) then
								-- we refuel if possible, desirable and needed
								if (turtle.refuel()) then
									print("Refueled " .. (turtle.getFuelLevel() - previous_fuel_level) .. " units from slot " .. slot_idx .. " (" .. slot_info.name ..")");
									print("New fuel level: " .. turtle.getFuelLevel());
								end;
							end;
						else
							print("Fuel `" .. slot_info.name .. "` at slot " .. slot_idx .. " is blacklisted");
						end;
					end;


				end;
			else
				-- this is just the end of a column. We just shift one column and invert N/S
				if (returning_x) then
					navigation.dig_and_go("W");
				else
					navigation.dig_and_go("E");
				end;
				returning_y = (not returning_y);
			end;
		else
			-- no. keep digging N/S
			if (returning_y) then
				navigation.dig_and_go("S");
			else
				navigation.dig_and_go("N");
			end;
		end;


		if (turtle.getFuelLevel() < (initial_step_ahead + initial_step_right + math.abs(curr_offset_x) + math.abs(curr_offset_y))) then
			low_fuel = true;
			print("Fuel level barely sufficient to return to base. Returning to starting point");
		end;
		
	end;

	navigation.back_to_start();

	-- let's move back to the starting point
	for step_ahead_loop = 1, initial_step_right do
		navigation.dig_and_go("W");
	end;
	for step_ahead_loop = 1, initial_step_ahead do
		navigation.dig_and_go("S");
	end;
	navigation.heading_set("N");
	navigation.dig_and_go("D");
